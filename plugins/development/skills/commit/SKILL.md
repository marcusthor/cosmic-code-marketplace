---
name: commit
description: Generates storytelling-focused Conventional Commits messages with optional Jira context integration. This skill should be used when the user says "commit", "git commit", asks to commit changes, or when work is complete and ready to commit.
allowed-tools:
  - Bash(git add:*)
  - Bash(git status:*)
  - Bash(git commit:*)
  - Bash(git diff:*)
  - Bash(git log:*)
  - Bash(git branch:*)
  - AskUserQuestion
---

# Git Commit Skill

Generate Conventional Commits messages that tell a complete story for future code archeology, with optional Jira ticket context integration.

## Critical Rules

1. **NEVER add AI signatures to commits** - No exceptions:
   - No `ðŸ¤– Generated with [Claude Code](...)`
   - No `Co-Authored-By: Claude ...`
   - No `Generated by Claude` or similar
   - Commits must appear as if written by a human developer
2. **NEVER use `git add -A` or `git add .`** - Only commit staged files
3. **Always ask WHY** - Use AskUserQuestion to understand the motivation
4. **Atomic commits** - Split unrelated changes

## Workflow

### Step 1: Gather Context

```bash
git status
git diff --staged
git log --oneline -5
git branch --show-current
```

### Step 2: Extract Jira Ticket (if applicable)

Parse the current branch name for Jira ticket IDs:
- `PROJ-123-feature-name`
- `feature/PROJ-123-description`
- `PROJ-123`

If found, reference the ticket in the commit footer.

### Step 3: Ask for Context (Human-in-the-Loop)

**ALWAYS use AskUserQuestion to ask WHY the change was made.**

Based on the diff, generate 3-4 plausible options for why the change was made. Present these as multiple choice options.

```
Question: "Why did you make these changes?"
Options:
- "Fix bug where X was causing Y"
- "Add new feature for Z"
- "Refactor to improve maintainability"
- (User can select "Other" for custom explanation)
```

Options should be specific to the actual changes observed in the diff, not generic.

### Step 4: Determine Commit Strategy

- **Small changes**: Single-line commit message
- **Significant changes**: Multi-line storytelling format
- **Mixed changes**: Suggest splitting into multiple commits

### Step 5: Create Commit

**Simple format** (for small, obvious changes):
```
<type>(<scope>): <description>
```

**Storytelling format** (for significant changes):
```
<type>(<scope>): <concise subject line>

Why this change was needed:
[User's explanation and context]

What changed:
[Technical summary of modifications]

Problem solved:
[Business/technical problem this addresses]

Refs: PROJ-123
```

Use heredoc for multi-line commits:
```bash
git commit -m "$(cat <<'EOF'
type(scope): subject line

Why this change was needed:
[explanation]

What changed:
[technical summary]

Refs: PROJ-123
EOF
)"
```

## Commit Types

| Type | Description |
|------|-------------|
| `feat` | New feature |
| `fix` | Bug fix |
| `docs` | Documentation only |
| `style` | Formatting, whitespace (no code change) |
| `refactor` | Code restructuring (no feature/fix) |
| `perf` | Performance improvement |
| `test` | Adding or updating tests |
| `build` | Build system or dependencies |
| `ci` | CI configuration |
| `chore` | Other changes (tooling, etc.) |
| `revert` | Revert a previous commit |

## Commit Message Rules

1. **Imperative mood** - "add" not "added"
2. **First line < 72 characters**
3. **Lowercase** - Type and description in lowercase
4. **No period** - Don't end the subject line with a period

## Breaking Changes

Indicate with `!` before the colon:
```
feat(api)!: change authentication method

BREAKING CHANGE: JWT tokens now required for all endpoints
```

## Split Criteria

Consider splitting commits when detecting:
- Different concerns (feature + fix)
- Mixed types (docs + refactor)
- Unrelated file patterns
- Large number of changes (> 10 files)

## Options

- `--no-verify`: Skip pre-commit hooks (Husky)

## Examples

### Example 1: Feature with Jira Context

```
feat(mcp): add tool execution timeout handling

Why this change was needed:
Tools were hanging indefinitely when external APIs failed to respond,
blocking the entire MCP server.

What changed:
- Added configurable timeout wrapper around tool execution
- Implemented graceful timeout error messages

Problem solved:
External API failures no longer block the MCP server. Users now receive
clear timeout errors instead of indefinite hanging.

Refs: AGP-582
```

### Example 2: Simple Bug Fix

```
fix(auth): prevent token refresh race condition
```

### Example 3: Refactoring

```
refactor(api): extract validation logic to shared module

Why this change was needed:
Input validation was duplicated across 7 different API endpoints,
making it difficult to maintain consistent validation rules.

What changed:
- Created shared validation utilities in packages/validation
- Removed 200+ lines of duplicated validation code

Problem solved:
Validation logic is now centralized and consistent across all endpoints.
```

## Storytelling Emphasis

Create commit messages that future developers will appreciate when doing code archeology. The message should answer:

- **What** changed? (technical summary)
- **Why** was this needed? (business context, user explanation)
- **What problem** does it solve? (from context and user input)

## Important Notes

Use heredoc for multi-line commits - Ensures proper formatting
Reference Jira tickets when found in branch name
Be specific in technical summaries
Think about the reader - someone debugging this code in 6 months
No co-authors - Never add "Co-Authored-By" or mention Claude Code
