---
name: commit
description: Creates well-formatted git commits with conventional commit messages and emoji. This skill should be used when committing code changes, creating atomic commits, or following conventional commit standards.
allowed-tools:
  - Bash(git add:*)
  - Bash(git status:*)
  - Bash(git commit:*)
  - Bash(git diff:*)
  - Bash(git log:*)
---

# Git Commit Skill

Creates well-formatted commits following conventional commit standards with emoji prefixes.

## Commit Format

```
<emoji> <type>: <description>
```

**Example:** `âœ¨ feat: add user authentication flow`

## Commit Types

| Type | Emoji | Description |
|------|-------|-------------|
| `feat` | âœ¨ | New feature |
| `fix` | ğŸ› | Bug fix |
| `docs` | ğŸ“ | Documentation |
| `style` | ğŸ’„ | Formatting (no code change) |
| `refactor` | â™»ï¸ | Code restructuring |
| `perf` | âš¡ | Performance improvement |
| `test` | âœ… | Tests |
| `chore` | ğŸ”§ | Build/tools |

## Extended Emoji Map

| Emoji | Use Case |
|-------|----------|
| ğŸš€ | CI/CD |
| ğŸš¨ | Fix warnings |
| ğŸ”’ï¸ | Security |
| ğŸšš | Move/rename files |
| ğŸ—ï¸ | Architecture changes |
| â• | Add dependency |
| â– | Remove dependency |
| ğŸŒ± | Seed data |
| ğŸ§‘â€ğŸ’» | Developer experience |
| ğŸ·ï¸ | Types |
| ğŸ‘” | Business logic |
| ğŸš¸ | UX improvements |
| ğŸ©¹ | Minor fix |
| ğŸ¥… | Error handling |
| ğŸ”¥ | Remove code/files |
| ğŸ¨ | Structure/format |
| ğŸš‘ï¸ | Hotfix |
| ğŸ‰ | Initial commit |
| ğŸ”– | Release/version tag |
| ğŸš§ | Work in progress |
| ğŸ’š | Fix CI |
| ğŸ“Œ | Pin dependencies |
| ğŸ‘· | CI build system |
| ğŸ“ˆ | Analytics |
| âœï¸ | Fix typos |
| âªï¸ | Revert changes |
| ğŸ“„ | License |
| ğŸ’¥ | Breaking changes |
| ğŸ± | Assets |
| â™¿ï¸ | Accessibility |
| ğŸ’¡ | Comments |
| ğŸ—ƒï¸ | Database |
| ğŸ”Š | Add logs |
| ğŸ”‡ | Remove logs |
| ğŸ™ˆ | Gitignore |
| ğŸ“¸ | Snapshots |
| âš—ï¸ | Experiments |
| ğŸš© | Feature flags |
| ğŸ’« | Animations |
| âš°ï¸ | Dead code removal |
| ğŸ¦º | Validation |
| âœˆï¸ | Offline support |

## Commit Process

### Step 1: Check Current State

```bash
git status
```

Determine if there are:
- Staged changes (commit only these)
- Unstaged changes (analyze if they should be staged)

### Step 2: Analyze Changes

```bash
git diff --staged
git diff
```

Review the diff to:
- Understand what changed
- Identify if changes should be split
- Determine appropriate commit type

### Step 3: Review Recent Commits

```bash
git log --oneline -5
```

Match the repository's commit style and conventions.

### Step 4: Stage Files (if needed)

Only stage related changes. If multiple unrelated changes exist, suggest splitting.

### Step 5: Create Commit

```bash
git commit -m "<emoji> <type>: <description>"
```

## Commit Message Rules

1. **Imperative mood** - "add" not "added"
2. **First line < 72 characters**
3. **Atomic commits** - Single purpose per commit
4. **Split unrelated changes** - Don't mix features with fixes

## Split Criteria

Consider splitting commits when detecting:
- Different concerns (feature + fix)
- Mixed types (docs + refactor)
- Unrelated file patterns
- Large number of changes (> 10 files)

## Options

- `--no-verify`: Skip pre-commit hooks (Husky)

## Critical Rules

1. **NEVER add Claude signature to commits** - No "Generated by Claude" or similar
2. **Only commit staged files** if any exist
3. **Analyze diff** before committing to suggest appropriate type
4. **Suggest splitting** if changes are unrelated
5. **Husky handles pre-commit checks** automatically
